import java.io.*;
import java.util.*;
import java.util.regex.*;

public class MethodDuplicateFinder {

    // üîß Hardcoded list of target classes to compare against
    private static final List<String> TARGET_CLASSES = Arrays.asList(
        "B.java",
        "C.java",
        "CommonUtils.java"
    );

    // üîß List of method names to ignore
    private static final Set<String> IGNORE_METHODS = Set.of("init", "setup");

    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println("Usage: java MethodDuplicateFinder <SourceClass.java> <DirectoryPath>");
            return;
        }

        String sourceClassFile = args[0];
        String directoryPath = args[1];

        File dir = new File(directoryPath);
        if (!dir.isDirectory()) {
            System.out.println("Invalid directory: " + directoryPath);
            return;
        }

        File sourceFile = new File(dir, sourceClassFile);
        if (!sourceFile.exists()) {
            System.out.println("Source class file not found: " + sourceClassFile);
            return;
        }

        String sourceClassName = sourceClassFile.replace(".java", "");
        Set<String> sourceMethods = extractMethodNames(sourceFile, sourceClassName);
        Map<String, List<String>> duplicatesMap = new HashMap<>();
        Set<String> allDuplicates = new HashSet<>();

        for (String targetClassName : TARGET_CLASSES) {
            File file = new File(dir, targetClassName);
            if (!file.exists()) {
                System.out.println("‚ö†Ô∏è Skipping: " + targetClassName + " (not found)");
                continue;
            }

            String targetSimpleName = targetClassName.replace(".java", "");
            Set<String> targetMethods = extractMethodNames(file, targetSimpleName);

            for (String method : sourceMethods) {
                if (targetMethods.contains(method)) {
                    allDuplicates.add(method);
                    duplicatesMap.computeIfAbsent(method, k -> new ArrayList<>())
                                 .add(targetSimpleName);
                }
            }
        }

        // üîÅ Print duplicates
        System.out.println("\nüßæ Duplicate Method Report for " + sourceClassFile + ":");
        if (duplicatesMap.isEmpty()) {
            System.out.println("‚úÖ No duplicate method names found in target classes.");
        } else {
            for (Map.Entry<String, List<String>> entry : duplicatesMap.entrySet()) {
                System.out.println("üîÅ " + entry.getKey() + " ‚Üí Also found in: " + entry.getValue());
            }
        }

        // ‚ûï Print new (non-duplicate) methods
        System.out.println("\n‚ûï New Methods to be Coded:");
        for (String method : sourceMethods) {
            if (!allDuplicates.contains(method)) {
                System.out.println("üÜï " + method);
            }
        }
    }

    private static Set<String> extractMethodNames(File file, String className) throws IOException {
        Set<String> methodNames = new HashSet<>();
        Pattern pattern = Pattern.compile("\\b(?:public|protected|private)?\\s*(?:static\\s*)?\\S+\\s+(\\w+)\\s*\\([^)]*\\)\\s*\\{?");

        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                Matcher matcher = pattern.matcher(line.trim());
                if (matcher.find()) {
                    String methodName = matcher.group(1);
                    if (!methodName.equals(className) && !IGNORE_METHODS.contains(methodName)) {
                        methodNames.add(methodName);
                    }
                }
            }
        }
        return methodNames;
    }
}
