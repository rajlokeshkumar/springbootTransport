import java.io.*;
import java.util.*;
import java.util.regex.*;

public class MethodDuplicateFinder {

    // üîß Hardcoded list of target class file names (in different packages)
    private static final List<String> TARGET_CLASSES = Arrays.asList(
        "C.java",
        "D.java"
    );

    // üîß List of method names to ignore
    private static final Set<String> IGNORE_METHODS = Set.of("init", "setup");

    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println("Usage: java MethodDuplicateFinder <SourceClass.java> <SrcDirectoryPath>");
            return;
        }

        String sourceClassName = args[0];
        String srcRoot = args[1];

        File srcDir = new File(srcRoot);
        if (!srcDir.isDirectory()) {
            System.out.println("Invalid source directory: " + srcRoot);
            return;
        }

        // Find the source file by walking src directory
        File sourceFile = findFileRecursively(srcDir, sourceClassName);
        if (sourceFile == null) {
            System.out.println("‚ùå Source file " + sourceClassName + " not found under " + srcRoot);
            return;
        }

        String sourceSimpleName = sourceClassName.replace(".java", "");
        Set<String> sourceMethods = extractMethodNames(sourceFile, sourceSimpleName);
        Map<String, List<String>> duplicatesMap = new HashMap<>();
        Set<String> allDuplicates = new HashSet<>();

        for (String targetFileName : TARGET_CLASSES) {
            File targetFile = findFileRecursively(srcDir, targetFileName);
            if (targetFile == null) {
                System.out.println("‚ö†Ô∏è Skipping: " + targetFileName + " (not found)");
                continue;
            }

            String targetClassName = targetFileName.replace(".java", "");
            Set<String> targetMethods = extractMethodNames(targetFile, targetClassName);

            for (String method : sourceMethods) {
                if (targetMethods.contains(method)) {
                    allDuplicates.add(method);
                    duplicatesMap.computeIfAbsent(method, k -> new ArrayList<>())
                                 .add(targetClassName);
                }
            }
        }

        System.out.println("\nüßæ Duplicate Method Report for " + sourceClassName + ":");
        if (duplicatesMap.isEmpty()) {
            System.out.println("‚úÖ No duplicate method names found in target classes.");
        } else {
            for (Map.Entry<String, List<String>> entry : duplicatesMap.entrySet()) {
                System.out.println("üîÅ " + entry.getKey() + " ‚Üí Also found in: " + entry.getValue());
            }
        }

        System.out.println("\n‚ûï New Methods to be Coded:");
        for (String method : sourceMethods) {
            if (!allDuplicates.contains(method)) {
                System.out.println("üÜï " + method);
            }
        }
    }

    // Recursively finds a .java file with given name in a directory tree
    private static File findFileRecursively(File dir, String fileName) {
        File[] files = dir.listFiles();
        if (files == null) return null;

        for (File file : files) {
            if (file.isDirectory()) {
                File found = findFileRecursively(file, fileName);
                if (found != null) return found;
            } else if (file.getName().equals(fileName)) {
                return file;
            }
        }
        return null;
    }

    private static Set<String> extractMethodNames(File file, String className) throws IOException {
        Set<String> methodNames = new HashSet<>();
        Pattern pattern = Pattern.compile("\\b(?:public|protected|private)?\\s*(?:static\\s*)?\\S+\\s+(\\w+)\\s*\\([^)]*\\)\\s*\\{?");

        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                Matcher matcher = pattern.matcher(line.trim());
                if (matcher.find()) {
                    String methodName = matcher.group(1);
                    if (!methodName.equals(className) && !IGNORE_METHODS.contains(methodName)) {
                        methodNames.add(methodName);
                    }
                }
            }
        }

        return methodNames;
    }
}
